(window.webpackJsonp=window.webpackJsonp||[]).push([[169],{778:function(v,_,a){"use strict";a.r(_);var t=a(17),c=Object(t.a)({},(function(){var v=this,_=v.$createElement,a=v._self._c||_;return a("ContentSlotsDistributor",{attrs:{"slot-key":v.$parent.slotKey}},[a("h1",{attrs:{id:"存储器"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#存储器"}},[v._v("#")]),v._v(" 存储器")]),v._v(" "),a("h2",{attrs:{id:"层次结构"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#层次结构"}},[v._v("#")]),v._v(" 层次结构")]),v._v(" "),a("ol",[a("li",[v._v("寄存器，容量小速度快，在CPU内")]),v._v(" "),a("li",[v._v("一级cache：高速缓冲存储器（容量小，速度快）在cpu内")]),v._v(" "),a("li",[v._v("二级cache：容量大，速度慢，在主板内")]),v._v(" "),a("li",[v._v("主存储器（主存），计算机系统主要存储器，存放运行期间的程序和数据，容量大，速度慢，在主板内")]),v._v(" "),a("li",[v._v("外存储器（外存），大容量辅助存储器")]),v._v(" "),a("li",[v._v("cpu直接访问的是内存器：cache+主存，可以直接进行信息交换。")])]),v._v(" "),a("h2",{attrs:{id:"分类"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#分类"}},[v._v("#")]),v._v(" 分类")]),v._v(" "),a("ol",[a("li",[v._v("随机存储器（RAM），可以根据一个地址，根据地址找到对应数据，任何存储单元内容都能被随机存取")]),v._v(" "),a("li",[v._v("顺序存储器，只能按某种顺序存取，如磁带")]),v._v(" "),a("li",[v._v("半顺序存储器，磁道方向顺序存取，垂直半径随机存取")])]),v._v(" "),a("h3",{attrs:{id:"按存储读写分"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#按存储读写分"}},[v._v("#")]),v._v(" 按存储读写分")]),v._v(" "),a("ol",[a("li",[v._v("只读存储器（ROM）")]),v._v(" "),a("li",[v._v("随机存储器（RAM）")])]),v._v(" "),a("h3",{attrs:{id:"按易失分"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#按易失分"}},[v._v("#")]),v._v(" 按易失分")]),v._v(" "),a("ol",[a("li",[v._v("易失/非易失存储器")])]),v._v(" "),a("h2",{attrs:{id:"技术指标"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#技术指标"}},[v._v("#")]),v._v(" 技术指标")]),v._v(" "),a("ol",[a("li",[a("p",[v._v("字存储单元：存放一个机器字的存储单元，单元地址为字地址")])]),v._v(" "),a("li",[a("p",[v._v("字节存储单元：存储一个字节单元，单元地址为字节地址")])]),v._v(" "),a("li",[a("p",[v._v("存储容量：")]),v._v(" "),a("ul",[a("li",[v._v("主存容量：以Byte为单位衡量")]),v._v(" "),a("li",[v._v("半导体存储芯片：以Bit为基本单位")]),v._v(" "),a("li",[v._v("存储容量以2^10=1024规律表达")]),v._v(" "),a("li",[v._v("厂商以10^3=1000规律表达")])])]),v._v(" "),a("li",[a("p",[v._v("存取时间（访问时间）")]),v._v(" "),a("ul",[a("li",[v._v("一次发出读写命令到数据传输操作完成所经过的时间")])])]),v._v(" "),a("li",[a("p",[v._v("存取周期")]),v._v(" "),a("ul",[a("li",[v._v("两次存储器访问所允许的最小时间间隔")]),v._v(" "),a("li",[v._v("存取周期大于等于存取时间")])])]),v._v(" "),a("li",[a("p",[v._v("存储器带宽")]),v._v(" "),a("ul",[a("li",[v._v("单位时间内存储器所存取的信息量，以bit/秒或者Byte/秒")])])])]),v._v(" "),a("p",[a("strong",[v._v("速度指标")]),v._v("：存取时间，存取周期，存储器带宽")]),v._v(" "),a("h2",{attrs:{id:"sram存储器"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#sram存储器"}},[v._v("#")]),v._v(" SRAM存储器")]),v._v(" "),a("blockquote",[a("p",[v._v("静态存储器")])]),v._v(" "),a("ul",[a("li",[v._v("以触发器为基本存储单元")]),v._v(" "),a("li",[v._v("不需要额外的刷新电路")]),v._v(" "),a("li",[v._v("速度快，集成度低，功耗和价格较高")])]),v._v(" "),a("h3",{attrs:{id:"存储体"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#存储体"}},[v._v("#")]),v._v(" 存储体")]),v._v(" "),a("p",[v._v("将各个字的同一个字的一位集成在一个芯片上，32位排成256*128矩阵")]),v._v(" "),a("h3",{attrs:{id:"地址译码器"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#地址译码器"}},[v._v("#")]),v._v(" 地址译码器")]),v._v(" "),a("p",[v._v("使用双译码方式")]),v._v(" "),a("h3",{attrs:{id:"读写的互锁逻辑"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#读写的互锁逻辑"}},[v._v("#")]),v._v(" 读写的互锁逻辑")]),v._v(" "),a("p",[v._v("G1为片选信号，CS有效的时候，G1G2均被打开，G1与G2门是互锁的")]),v._v(" "),a("h2",{attrs:{id:"dram存储器"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#dram存储器"}},[v._v("#")]),v._v(" DRAM存储器")]),v._v(" "),a("blockquote",[a("p",[v._v("动态存储")])]),v._v(" "),a("ul",[a("li",[v._v("以单个MOS管为基本存储单元")]),v._v(" "),a("li",[v._v("要不断进行刷新操作")]),v._v(" "),a("li",[v._v("集成度高，价格低，功耗小，但是速度慢")])]),v._v(" "),a("h2",{attrs:{id:"chache"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#chache"}},[v._v("#")]),v._v(" chache")]),v._v(" "),a("p",[v._v("主要目的是提升存储器速度，即cpu与主存之间的速度，由SRAM组成")]),v._v(" "),a("p",[v._v("CPU与chache之间的数据交换以"),a("strong",[v._v("字节")]),v._v("为单位")]),v._v(" "),a("p",[v._v("chache与主存之间的数据传送以"),a("strong",[v._v("数据块")]),v._v("为单位")]),v._v(" "),a("h3",{attrs:{id:"主要原理"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#主要原理"}},[v._v("#")]),v._v(" 主要原理")]),v._v(" "),a("ol",[a("li",[v._v("cache发出访问操作，由cache控制器判断当前请求的字是否在cache中，在则命中，不在则不命中")]),v._v(" "),a("li",[v._v("若命中在判断读or写请求\n"),a("ul",[a("li",[v._v("若读：直接对cache读，与主存无关")]),v._v(" "),a("li",[v._v("若写：\n"),a("ul",[a("li",[v._v("cache单元和主存单元同时进行写")]),v._v(" "),a("li",[v._v("只更新cache，在移出该数据块的时候再修改主存")]),v._v(" "),a("li",[v._v("只写入主存，在cache中添加标记")])])])])]),v._v(" "),a("li",[v._v("未命中时，需要cpu和主存进行寻找\n"),a("ul",[a("li",[v._v("若读：在主存中读取所需的字，传给cpu，把含有该字的块送往cache（"),a("strong",[v._v("装入通过")]),v._v("）若cache已经满了则进行替换算法。")]),v._v(" "),a("li",[v._v("若写：直接写入主存")])])])]),v._v(" "),a("p",[v._v("主存的数据中部分地址会拷贝到cache上（"),a("strong",[v._v("地址映射")]),v._v("），cpu在cache中查询相关地址，cpu在其找到称为"),a("strong",[v._v("命中")]),v._v("，进行字交换，如果cpu在cache中没有找到则在主存中查找并进行数据交换")]),v._v(" "),a("ul",[a("li",[v._v("地址映射：主存的数据中部分地址会拷贝到cache上")]),v._v(" "),a("li",[v._v("替换策略：cache数据存满后，还要继续进行数据存放，则可以进行数据的替换，即为替换策略，将最近最少使用的数据块会被替换掉")]),v._v(" "),a("li",[v._v("写一致性：对cache进行数据修改，则还需要对主存内对应的数据进行修改，即写一致性")]),v._v(" "),a("li",[v._v("性能评价：在cache中的命中率，寻找时间，平均访问时间等等")])]),v._v(" "),a("h3",{attrs:{id:"命中率计算"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#命中率计算"}},[v._v("#")]),v._v(" 命中率计算")]),v._v(" "),a("p",[v._v("为了增加性能即使cache满足CPU需要的部分占更高的比例，则需要cache的命中率"),a("strong",[v._v("接近于1")])]),v._v(" "),a("p",[v._v("Nc为cache完成存取的总次数")]),v._v(" "),a("p",[v._v("Nm为主存完成存取的总次数")]),v._v(" "),a("p",[v._v("h定义为命中率则有：h=Nc/（Nc+Nm）")]),v._v(" "),a("p",[a("strong",[v._v("tc")]),v._v("表示命中cache的访问时间，"),a("strong",[v._v("tm")]),v._v("未命中时主存访问时间，"),a("strong",[v._v("1-h")]),v._v("为未命中率，cache/主存系统的平均访问时间ta为"),a("strong",[v._v("ta = htc+（1-h）tm")])]),v._v(" "),a("p",[a("strong",[v._v("以最小的硬件代价")]),v._v("使cache/主存系统的ta越接近于tc越好")]),v._v(" "),a("p",[a("strong",[v._v("r=tm/tc")]),v._v("访问效率e=tc/ta=1/（r+（1-r）h）")]),v._v(" "),a("p",[a("strong",[v._v("r")]),v._v("值为5-10为好，"),a("strong",[v._v("h")]),v._v("接近于1越好")]),v._v(" "),a("h3",{attrs:{id:"地址映射"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#地址映射"}},[v._v("#")]),v._v(" 地址映射")]),v._v(" "),a("p",[v._v("若想主存将块放入cache中，必须使用某种方法把主存地址定位到cache中，这个过程为"),a("strong",[v._v("地址映射")])]),v._v(" "),a("p",[v._v("需要考虑")]),v._v(" "),a("ul",[a("li",[v._v("硬件时分容易实现")]),v._v(" "),a("li",[v._v("地址变换速率")])]),v._v(" "),a("p",[v._v("映射相关方法：cache通过地址映射确定主存块与cache行之间的对应关系，确定主存块应该存放在哪个cache行中")]),v._v(" "),a("ul",[a("li",[a("p",[v._v("全相联映射：将主存块存储到任意一个cache行")]),v._v(" "),a("p",[v._v("标记位为s位，主存块数为2^s")]),v._v(" "),a("ol",[a("li",[v._v("冲突概率小，cache利用率高")]),v._v(" "),a("li",[v._v("比较器难实现")])])]),v._v(" "),a("li",[a("p",[v._v("直接映射：将主存块存储到唯一的一个cache行")]),v._v(" "),a("p",[v._v("标记位为s-r，其他不变")])]),v._v(" "),a("li",[a("p",[v._v("组相联映射：可以将主存块存储到唯一的一个cache组的任意一个行（全相联与直接的结合）")])])]),v._v(" "),a("h3",{attrs:{id:"替换策略"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#替换策略"}},[v._v("#")]),v._v(" 替换策略")]),v._v(" "),a("ol",[a("li",[v._v("最不常用")]),v._v(" "),a("li",[v._v("最近最少使用")]),v._v(" "),a("li",[v._v("随机法")])]),v._v(" "),a("h3",{attrs:{id:"写操作策略"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#写操作策略"}},[v._v("#")]),v._v(" 写操作策略")]),v._v(" "),a("p",[v._v("写操作会有如下问题")]),v._v(" "),a("ul",[a("li",[v._v("确认命中问题")]),v._v(" "),a("li",[v._v("写入得数据字数不定")]),v._v(" "),a("li",[v._v("主存与cache内容不一致")])]),v._v(" "),a("p",[v._v("写入策略：")]),v._v(" "),a("ul",[a("li",[v._v("写回法：只修改cache内容，换出时对修改位进行判断决定写回还是舍弃，通过设置修改位来实现（1/0）")]),v._v(" "),a("li",[v._v("全写法：写命中时，cache与内存一起写")]),v._v(" "),a("li",[v._v("写一次法：与写回法一致，但是第一次cache命中得时候采用全写法")])])])}),[],!1,null,null,null);_.default=c.exports}}]);
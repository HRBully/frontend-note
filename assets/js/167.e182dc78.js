(window.webpackJsonp=window.webpackJsonp||[]).push([[167],{775:function(v,_,t){"use strict";t.r(_);var a=t(17),s=Object(a.a)({},(function(){var v=this,_=v.$createElement,t=v._self._c||_;return t("ContentSlotsDistributor",{attrs:{"slot-key":v.$parent.slotKey}},[t("h1",{attrs:{id:"指令"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#指令"}},[v._v("#")]),v._v(" 指令")]),v._v(" "),t("blockquote",[t("p",[v._v("指令是什么，完成一个功能的命令，指令是软件与硬件之间的桥梁")])]),v._v(" "),t("h2",{attrs:{id:"概念"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#概念"}},[v._v("#")]),v._v(" 概念")]),v._v(" "),t("p",[v._v("指令是执行计算机某种操作的命令")]),v._v(" "),t("h3",{attrs:{id:"分类"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#分类"}},[v._v("#")]),v._v(" 分类")]),v._v(" "),t("p",[v._v("层次上指令划分")]),v._v(" "),t("ul",[t("li",[v._v("微指令：微程序命令，属于硬件")]),v._v(" "),t("li",[v._v("宏指令：若干条机器指令组成，属于软件（一段程序）")]),v._v(" "),t("li",[v._v("机器指令：介于前两者之间，每条指令可以完成独立的算数运算和逻辑运算操作")])]),v._v(" "),t("h3",{attrs:{id:"指令系统"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#指令系统"}},[v._v("#")]),v._v(" 指令系统")]),v._v(" "),t("p",[v._v("一台计算机中所有机器指令的集合被称为指令系统")]),v._v(" "),t("h3",{attrs:{id:"发展"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#发展"}},[v._v("#")]),v._v(" 发展")]),v._v(" "),t("ol",[t("li",[v._v("20世纪50年代：只能定点运算，逻辑运算，数据传输，转移等几十个")]),v._v(" "),t("li",[v._v("60年代：乘除，浮点")]),v._v(" "),t("li",[v._v("70年代：复杂指令系统的出现：CISC，和精简指令系统的出现：RISC。")])]),v._v(" "),t("h2",{attrs:{id:"指令的性能"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#指令的性能"}},[v._v("#")]),v._v(" 指令的性能")]),v._v(" "),t("h3",{attrs:{id:"完备性"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#完备性"}},[v._v("#")]),v._v(" 完备性")]),v._v(" "),t("p",[v._v("一套指令系统中必须有必不可少的指令")]),v._v(" "),t("h3",{attrs:{id:"有效性"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#有效性"}},[v._v("#")]),v._v(" 有效性")]),v._v(" "),t("h3",{attrs:{id:"规整性"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#规整性"}},[v._v("#")]),v._v(" 规整性")]),v._v(" "),t("ul",[t("li",[v._v("对称性匀齐性")]),v._v(" "),t("li",[v._v("一致性")])]),v._v(" "),t("h3",{attrs:{id:"兼容性"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#兼容性"}},[v._v("#")]),v._v(" 兼容性")]),v._v(" "),t("h2",{attrs:{id:"指令格式"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#指令格式"}},[v._v("#")]),v._v(" 指令格式")]),v._v(" "),t("blockquote",[t("p",[v._v("指令需要做什么操作，需要什么操作，结果送到哪里，下一条指令从哪里取")])]),v._v(" "),t("p",[v._v("指令格式包括两个部分即操作码字段OP+地址码字段A")]),v._v(" "),t("h3",{attrs:{id:"操作码"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#操作码"}},[v._v("#")]),v._v(" 操作码")]),v._v(" "),t("p",[v._v("以OP表示，这条指令进行什么操作，如加减乘除，每一种编码代表一种指令，且每个指令的op位数必须满足"),t("strong",[v._v("N<=2^n")]),v._v("N为指令位数，n为op位数，在指令系统种op字段的长度一般是固定的，虽然这种行为会导致信息冗余极大。")]),v._v(" "),t("h3",{attrs:{id:"地址码"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#地址码"}},[v._v("#")]),v._v(" 地址码")]),v._v(" "),t("p",[v._v("根据指令中有几个操作数的地址，可称为几操作数指令或几地址指令")]),v._v(" "),t("ul",[t("li",[t("p",[v._v("三地址指令：被操作数，操作数，操作结果")]),v._v(" "),t("p",[v._v("操作码-A1-A2-A3：(A1)OP(A2)->A3")]),v._v(" "),t("ul",[t("li",[v._v("op：操作码")]),v._v(" "),t("li",[v._v("A1：被操作数地址")]),v._v(" "),t("li",[v._v("A2：操作数地址")]),v._v(" "),t("li",[v._v("A3：存放结果地址")])])]),v._v(" "),t("li",[t("p",[v._v("二地址指令：双操作数")]),v._v(" "),t("p",[v._v("操作码-A1-A2：(A1)OP(A2)->A1")]),v._v(" "),t("ul",[t("li",[v._v("op：操作码")]),v._v(" "),t("li",[v._v("A1：被操作数地址，存放结果地址")]),v._v(" "),t("li",[v._v("A2：操作数地址")])]),v._v(" "),t("p",[v._v("二地址根据操作数的物理地址分为")]),v._v(" "),t("ul",[t("li",[v._v("SS-存储器-存储器类型")]),v._v(" "),t("li",[v._v("RR-寄存器-寄存器类型（速度快）")]),v._v(" "),t("li",[v._v("SR-存储器-寄存器类型")])])]),v._v(" "),t("li",[t("p",[v._v("单地址指令：操作数")])]),v._v(" "),t("li",[t("p",[v._v("零地址指令：只有操作码")])])]),v._v(" "),t("h3",{attrs:{id:"指令字长度"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#指令字长度"}},[v._v("#")]),v._v(" 指令字长度")]),v._v(" "),t("ul",[t("li",[v._v("指令字长：一个指令字包含的二进制代码位数")]),v._v(" "),t("li",[v._v("机器字长："),t("strong",[v._v("计算机能够直接处理的二进制数据的位数")])]),v._v(" "),t("li",[v._v("单字长指令：指令字长度=机器字长")]),v._v(" "),t("li",[v._v("半字长指令：指令字长度=机器字长*1/2")]),v._v(" "),t("li",[v._v("双字长指令：指令字长度=机器字长*2")])]),v._v(" "),t("h4",{attrs:{id:"多字长指令"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#多字长指令"}},[v._v("#")]),v._v(" 多字长指令")]),v._v(" "),t("ul",[t("li",[v._v("优点：提供足够的地址位来解决访问内存单元的寻址问题")]),v._v(" "),t("li",[v._v("缺点：降低运算速度")])]),v._v(" "),t("h4",{attrs:{id:"等长指令"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#等长指令"}},[v._v("#")]),v._v(" 等长指令")]),v._v(" "),t("ul",[t("li",[v._v("优点：字结构简单")])]),v._v(" "),t("h4",{attrs:{id:"非等长指令"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#非等长指令"}},[v._v("#")]),v._v(" 非等长指令")]),v._v(" "),t("ul",[t("li",[v._v("优点：结构灵活")]),v._v(" "),t("li",[v._v("缺点：控制复杂")])]),v._v(" "),t("h2",{attrs:{id:"指令和数据的寻址"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#指令和数据的寻址"}},[v._v("#")]),v._v(" 指令和数据的寻址")]),v._v(" "),t("blockquote",[t("p",[v._v("存储器既可以存数据又可以存指令")]),v._v(" "),t("p",[v._v("存储单元的编号是该操作数或指令在存储器的地址")])]),v._v(" "),t("h3",{attrs:{id:"寻址方式"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#寻址方式"}},[v._v("#")]),v._v(" 寻址方式")]),v._v(" "),t("ul",[t("li",[v._v("地址指令方式")]),v._v(" "),t("li",[v._v("相联存储方式")]),v._v(" "),t("li",[v._v("堆栈存取方式")])]),v._v(" "),t("p",[v._v("采用地址指定方式时，形成操作数或指令地址方式，在内存中"),t("strong",[v._v("指令寻址")]),v._v("与"),t("strong",[v._v("数据寻址")]),v._v("是交替进行的")]),v._v(" "),t("h3",{attrs:{id:"指令寻址方式-简单"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#指令寻址方式-简单"}},[v._v("#")]),v._v(" 指令寻址方式（简单）")]),v._v(" "),t("h4",{attrs:{id:"寻址方式-2"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#寻址方式-2"}},[v._v("#")]),v._v(" 寻址方式")]),v._v(" "),t("ul",[t("li",[t("p",[v._v("顺序寻址方式：按照指令地址从小到大一个个顺序进行，一条指令接着一条指令顺序执行")]),v._v(" "),t("p",[v._v("指令按照顺序排序，程序根据指示寻找顺序执行")])]),v._v(" "),t("li",[t("p",[v._v("跳跃寻址方式：程序转移执行顺序的时候指令的寻址就采用跳跃寻址方式，采用指令跳跃寻址可以实现程序的转移或构建循环程序")]),v._v(" "),t("p",[v._v("**JMP（跳跃）**上会有一个指令的地址，这个地址会送往计数器，使其替换指令地址，然后根据这个新的指令地址来进行执行。")])])]),v._v(" "),t("h4",{attrs:{id:"操作数基本寻址"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#操作数基本寻址"}},[v._v("#")]),v._v(" 操作数基本寻址")]),v._v(" "),t("p",[v._v("指令中的操作数字段的地址码是由形式地址和变址，间址组合形成的，所以其寻址")]),v._v(" "),t("p",[t("strong",[v._v("操作数的寻址概括为：根据间址，变址组合变为操作数有效地址过程")])]),v._v(" "),t("ul",[t("li",[t("p",[v._v("形式地址：偏移量，指令字结构中给定的地址量")])]),v._v(" "),t("li",[t("p",[v._v("寻址方式特征位：由间址和变址组成")])]),v._v(" "),t("li",[t("p",[v._v("有效地址（"),t("strong",[v._v("目标")]),v._v("）：对于形式地址进行一定计算而得到的操作数实际地址（"),t("strong",[v._v("操作数到底存储在哪里")]),v._v("）由寻址方式和形式地址共同确定")])])]),v._v(" "),t("h4",{attrs:{id:"隐含寻址"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#隐含寻址"}},[v._v("#")]),v._v(" 隐含寻址")]),v._v(" "),t("blockquote",[t("p",[v._v("操作数的地址不明显给出，在指令中隐含着操作数的地址（"),t("strong",[v._v("一地址")]),v._v("）")])]),v._v(" "),t("p",[v._v("如AND 0FH，把累加器AC的内容与立即数0FH相"),t("strong",[v._v("与")])]),v._v(" "),t("h4",{attrs:{id:"立即寻址"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#立即寻址"}},[v._v("#")]),v._v(" 立即寻址")]),v._v(" "),t("p",[v._v("所需操作数由指令部分直接给出，操作数包含在指令内，所以我们取指令的时候可以被立即取出，"),t("strong",[v._v("速度非常快")]),v._v("，但是指令字长度有限，其操作数的位数限制了所表示数的范围，寻址方式灵活性"),t("strong",[v._v("最差")])]),v._v(" "),t("h4",{attrs:{id:"直接寻址"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#直接寻址"}},[v._v("#")]),v._v(" 直接寻址")]),v._v(" "),t("p",[v._v("指令中地址码字段给出的地址A就是操作数的有效地址，且其操作数的地址是无法修改的，所以又叫"),t("strong",[v._v("绝对寻址")])]),v._v(" "),t("p",[v._v("ADD AX [1000H]  —— （AX）+（1000H）—》AX")]),v._v(" "),t("p",[v._v("1000H地址指向存储器（主存中）的地址，所以由于需要直接进行"),t("strong",[v._v("访问内存的操作")]),v._v("，所以大大降低了指令的执行速度")]),v._v(" "),t("h4",{attrs:{id:"间接寻址"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#间接寻址"}},[v._v("#")]),v._v(" 间接寻址")]),v._v(" "),t("p",[v._v("指令中地址码字段给出的地址A就是操作数的"),t("strong",[v._v("操作数地址指示器")]),v._v("（有点像相对和绝对的关系寻址）")]),v._v(" "),t("p",[v._v("访问两边主存，速度大大"),t("strong",[v._v("降低")]),v._v("，但是"),t("strong",[v._v("优点是可以灵活修改指示器，不必修改指令")])]),v._v(" "),t("p",[v._v("间接和直接寻址可以由"),t("strong",[v._v("操作码后的I进行区分")]),v._v(" 当I=0为直接寻址，I=1为间接寻址")]),v._v(" "),t("h4",{attrs:{id:"寄存器寻址"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#寄存器寻址"}},[v._v("#")]),v._v(" 寄存器寻址")]),v._v(" "),t("blockquote",[t("p",[v._v("指令的操作数存放在相应的寄存器中")])]),v._v(" "),t("p",[v._v("ADD AX BX "),t("strong",[v._v("RR型指令")])]),v._v(" "),t("p",[v._v("由于寄存器在cpu内部，所以直接在寄存器中取出比访问主存快的多，而且寄存器的数量较小，占位少，所以有效减少"),t("strong",[v._v("指令的地址码字段的长度")])]),v._v(" "),t("h4",{attrs:{id:"寄存器间接寻址"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#寄存器间接寻址"}},[v._v("#")]),v._v(" 寄存器间接寻址")]),v._v(" "),t("p",[v._v("操作数在主存储中，操作数地址放在某一通用寄存器中，指令的地址码部分给出该通用的寄存器编号，实现"),t("strong",[v._v("间接寄存器寻址")])]),v._v(" "),t("p",[v._v("指令较短，取值后需要进行访存才能得到操作数，执行速度慢一些，是目前计算机使用的"),t("strong",[v._v("主要使用寻址方式")])]),v._v(" "),t("h4",{attrs:{id:"偏移寻址"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#偏移寻址"}},[v._v("#")]),v._v(" 偏移寻址")]),v._v(" "),t("p",[v._v("由程序计数器PC提供基准地址，指令的地址码部分由给出的相对位移量A，两者相加后作为操作数的有效地址")]),v._v(" "),t("h3",{attrs:{id:"数据寻址方式-复杂"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#数据寻址方式-复杂"}},[v._v("#")]),v._v(" 数据寻址方式（复杂）")]),v._v(" "),t("h2",{attrs:{id:"堆栈寻址方式"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#堆栈寻址方式"}},[v._v("#")]),v._v(" 堆栈寻址方式")])])}),[],!1,null,null,null);_.default=s.exports}}]);
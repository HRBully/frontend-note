## 堆和栈

根据我们之前变量的分类，分为简单数据类型和复杂数据类型，其中简单数据类型为基本数据类型变量存储的是其值本身，而复杂数据类型比如对象，数组，等为，也被称为引用类型，其变量存储的是地址，通过地址来访问数据。

1. 栈：由操作系统自动分配释放存放函数的参数值，简单数据类型都存放在栈中
2. 堆：存储复杂数据类型，一般是由用户进行分配和释放，若用户不释放则会被垃圾回收机制回收

## 浅拷贝和深拷贝

简单地介绍浅拷贝和深拷贝，就是浅拷贝是只拷贝一层，更深层次的对象级别只拷贝引用，深拷贝是拷贝多层，每一层的数据都会拷贝

```js
var obj = {
    id:1,
    name:"cxy"
}
var o = {}
for (let item in obj) {
    o[item] = obj[item]
}
console.log(o)
```

我们需要知道一点，对象是引用数据类型，存储在堆内存中，在栈中保留引用地址，引用地址指向对应的数据以便于查找堆内存中的对象，我们在对象中嵌套一层。

```js
var obj = {
    id:1,
    name:"cxy",
    message:{
        name:"mxr"
    }
}
```

### 浅拷贝

我们将上述的对象进行拷贝，打印结果依旧证明了数据被拷贝了过来，但是这里有一个问题就是我们拷贝过来的是对象吗，不是一个指向那个底层对象的地址，我们将地址拷贝了过来指向这原来对象的数据，所以当我们修改了原来的对象数据，那么现在这个拷贝对象的数据也会被修改。

> es6给我们提供了浅拷贝的语法糖即```Objectassign()```

其语法格式为```Object.assign(target,source)```第一个参数为要拷贝的目标，第二个参数为被拷贝的目标对象

```js
Object.assign(o,obj)
```

### 深拷贝

> 深拷贝会将对象每一层的数据都拷贝过来

深拷贝我们是通过靠递归来实现的，因为深拷贝的原理是将对像整体地拷贝一份，然后在堆内存中开辟一个新的空间来存储

```js
var o = {}
function deepCopy( newobj , oldobj) {
    for (let i in oldobj) {
        var item = oldobj[i]
        //判断是否为数组
        if(item instanceof Array) {
            newobj[i] = []
            //递归
            deepCopy( newobj[i],item)
        } else if {
            //判断是否为对象
            newobj[i] = {}
            //递归
            deepCopy( newobj[i],item)
        } else {
            //简单数据类型赋值
            newobj[i] = item
        }
    }
}
deepCopy( o , obj )
```

### 赋值&浅拷贝&深拷贝

1. 赋值：当我们把一个对象赋值给一个新的变量时，**赋的其实是该对象的在栈中的地址，而不是堆中的数据**。也就是两个对象指向的是同一个存储空间，无论哪个对象发生改变，其实都是改变的存储空间的内容，因此，两个对象是联动的。

2. 浅拷贝：重新在堆中创建内存，拷贝前后对象的基本数据类型互不影响，但拷贝前后对象的引用类型因共享同一块内存，会相互影响。

3. 深拷贝：从堆内存中开辟一个新的区域存放新对象，对对象中的子对象进行递归拷贝,拷贝前后的两个对象互不影响。
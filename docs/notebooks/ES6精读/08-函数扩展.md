

# 函数扩展

## 默认参数

> 默认参数：如果没有值或传入值为`undefined`的情况下，默认函数参数允许定义好的形参对默认值进行初始化

下面我们来深入在js中函数使用默认参数的几个使用细节，包括**默认位置**，**重新创建的默认参数**，**与形参的结合使用**，**默认参数的作用域**以及**默认参数的暂时性死区**。

### ES5中的默认参数

在ES5时，还不能直接直接在参数中指定默认值，只能通过在函数域内声明变量并赋值，达到一个默认值的效果，但是这种不会**直观得表明默认值参数**。

```js
function fn(x, y) {
  var y = y || 1;
  return x + y;
}
console.log(fn(2)); // 3
```

就如上代码，我们通过`||`使`y`为函数的默认参数，这就是ES5的实现方式，但是如果我们的参数是布尔值的情况，就很容易造成问题。

### 全新默认参数的诞生

ES6函数参数默认值是可以直接在参数定义的时候进行默认赋值 ， 它的应用优化了代码结构，也增强了代码阅读者的体验。

```js
function fn(x, y=1) {
  return x + y;
}
console.log(fn(2)); // 3
```

值得注意的是参数定义的时候赋默认值需要注意一些细节。

#### 默认位置

默认参数值的位置一定为尾参数，即参数定义的尾部，下面的代码说明了如果默认参数的定义不放在尾部的情况

```js
function fn(x = 1, y) {
  return [x, y];
}
console.log(fn(2)); // [ 2, undefined ]
```

这种情况即我们无法再通过控制`x`没有值使用`x`的默认值，但是可以使用`undefined`来解决这个问题

```js
function fn(x = 1, y) {
  return [x, y];
}
console.log(fn(undefined,2)); // [ 1, 2 ]
```

即使这样还是建议将默认参数定义在参数的尾部。

#### 默认参数会影响函数的`length`属性

函数的`length`属性会返回函数的参数数量，其不包括默认参数，但是这里有一个问题，它仅仅只会返回参数区域内默认参数前的形式参数数量

```js
console.log(function fn(x, y = 1, z) {}.length); // 1
```

上面的函数`x`被设默认值，所以其`length`属性只返回`x`之前的形式参数数量，由此还是建议将默认参数放在参数定义的尾部

#### 重新创建的默认参数

函数在被调用的时候，参数会被创建，而默认参数有一个问题，就是他是否会因为函数的重复调用而被重新创建，在`JS`中是会的，来看下面的例子

```js
function fn(x, num = []) {
  num.push(x);
  return num;
}
console.log(fn(1)); // [1]
console.log(fn(2)); // [2]
```

通过上面两次调用`fn`函数并为`num`添加元素，而每次调用得到的结果证明了每次调用函数都会重新创建默认`num`。

#### 默认参数与形参的结合使用

我们可以将默认参数与形参结合起来使用，如下

```js
function fn(x, y, z = [x, y, 1]) {
  return z;
}
console.log(fn(1, 2)); // [ 1, 2, 1 ]
```

我们通过尾部的默认参数与前面的形式参数结合，可以是字符串形式，也可以是数组形式，也可以表达式，比如：`fn(x, y, z = x + y)`

#### 默认参数的作用域

深入默认参数的原理，其本质为使用`let`声明默认参数，所以这就造成了一个现象，即**当我们使用默认参数的时候，会开辟一个单独的作用域**，在作用域内访问一个变量的时候会进行一些步骤，为了更好的理解参数作用域，拿下面拿一段代码说明这个过程：

```js
let x = 1
function() fn(y = x) {
    return y
}
console.log(fn()) // 1
```

由于`y = x`是默认参数，所以参数定义的区域形成了一个单独作用域，在赋值的过程中，它将与引擎进行如下对话，这里忽略掉**LHS**与**RHS**查询，不是本文的要点

- 引擎在为`y`赋值的时候会询问当前作用域是否见过`x`，当前作用域即**参数声明的作用域**回答没有
- 引擎会向上走，询问上级作用域，此时为**全局作用域**，回答有`x`，引擎为`y`赋值

通过这个简单的例子可以理解默认参数的作用域是什么，其实它很常见，比如说`for`循环

```js
for(let i = 0; i < 100; i++) {}
```

#### 默认参数的隐藏性死区

在之前[let与const命令 - 掘金 (juejin.cn)](https://juejin.cn/post/7105688976874274830)这篇文章中提到了**暂时性性死区**的概念，而因为默认参数的特性，也会造成**暂时性死区**的现象

**暂时性死区**：在**代码块**中使用`let`声明变量前，该变量不可用，这种现象称为**暂时性死区**

```js
var x = 1
function fn(x = x) {
    return x;
}
```

在参数内`x = x`其本质为`let x = x`在` = x`的时候会出现暂时性死区的现象，因为在此刻出现问题的是`=`后的`x`，此时对`x`进行访问，所以，而此刻在该作用域内`let x`之前，没有声明`x`，所以该变量不可用，即我们所说的**暂时性死区**的现象。

## rest参数的使用

`rest`参数其本质就是扩展运算符在函数参数内的应用

```js
function fn(...arr) {
  for (let i = 0; i < arr.length; i++) {
    console.log(arr[i]);
  }
}
fn(1, 2, 3); // 1 2 3
```

如上，通过使用`...arr`作为函数参数的集合数组，在函数体内进行操作，而在`rest`未引入之前，一般是使用`arguments`对象来完成这个场景。

```js
function fn() {
  for (let i = 0; i < arguments.length; i++) {
    console.log(arguments[i]);
  }
}
fn(1, 2, 3);
```

其实在一些场景使用`arguments`对象有一些问题，因为其为对象形式，如果要使用一些数组独有的办法，比如排序，就会比较麻烦，就需要使用`Array`的原型方法`Array.prototype.slice`将其转换为数组，再进行数组操作。

## name属性的变化

函数name属性可以返回函数名，但是有很多种情况会改变这种现象，比如通过赋值来声明函数的形式，又比如将已经有名字的函数赋值给一个变量。

### 未命名函数赋值的`name`

当直接使用赋值的形式直接声明函数的情况，在ES6标准，其`name`属性返回的是声明的变量名，而在ES5标准，其返回的是空字符串。

```js
let fn = function () {};
console.log(fn.name); // fn
```

以上例子为ES6标准下的返回

### 具名函数再赋值的`name`

具名函数即函数以及拥有名字：`function fn(){}`，当再声明一个变量并为其赋值的情况，其`name`属性为原来的名字

```js
const fn_2 = function fn_1() {}
console.log(fn_2.name) // fn_1
```

以上打印出`fn_1`，为原来的函数名

## 箭头函数

箭头函数是ES6新增的定义函数的方式，我们可以使用`()=>{}`来顶替以前的函数定义方式，下面从**使用**与**注意细节**来刨析箭头函数

### 使用

#### 简略编写

当我们箭头函数函数只有一个参数的时候是可以将`()`省略，当代码块只有一行的时候可以将`{}`与`return`省略

```js
const fn = num => num.sort();
console.log(fn([2, 1, 3])); // [1,2,3]
```

如上代码块只有一个参数`num`且只有一行代码`return num.sort()`，所以将`()`，`{}`与`return`省略

#### 结合解构赋值

为了进一步简化还可以与解构赋值结合使用

```js
let person = {
  name: "猪痞恶霸",
  age: 12,
};
const fn = ({ name, age }) => name + "今年" + age + "岁了";
console.log(fn(person)); // 猪痞恶霸今年12岁了
```

使用解构赋值直接将`name`与`age`解构，替换了`person,name`的用法，使函数更加简洁。

#### 结合扩展运算符

在函数参数定义中可以结合`rest`参数搭配使用

```js
const fn = (...arr) => arr.sort();
console.log(fn(2, 1, 4)); // [1,2,4]
```

使用`...arr`将所有参数都包裹在内，在函数体内进行一些需要的操作。

#### `this`指向的改变

在箭头函数中使用`this`，它的指向是不变的，因为箭头函数没有拥有属于自己的`this`，其指向的是**函数定义时**所在的对象 , 所以箭头函数的出现往往就顶替了我们常用的`let _that = this`又或者在函数结尾使用绑定`this`指向的对象来解决在函数体内`this`的问题

```js
var name = "fzf404";
function set() {
  setTimeout(() => {
    console.log(this.name);
  }, 1000);
}
set(); // fzf404
set.call({ name: "猪痞恶霸" }); // 猪痞恶霸
```

如上例子，在全局中声明了一个`name`变量，我们再通过`call()`绑定新的对象`{ name: "猪痞恶霸" }`，在`set`函数执行的时候，箭头函数被定义，而被定义的时候其已经通过`set.call()`更改了指向的对象，所以打印出的是新的对象中的`name`属性，这就是箭头函数的`this`指向特点，如果是普通函数，其指向依旧是顶层对象。

#### 绑定`this`

在之前ES5可以通过`bind`，`call`，`apply`来显式绑定`this`对象，而箭头函数的出现打破了这种局面，同时也配套使用`::`来作为函数绑定的方式

`::`的使用方法：将要绑定的对象放在`::`的左边，函数放在`::`的右边，执行后，函数内的`this`就会指向绑定的对象

```js
obj::fn
// 等同于
fn.bind(obj)
```

如上，原来的显式绑定方式与使用`::`的绑定方式进行一个比较，看过二者的比较就可以了解`::`的使用了。

### 注意细节

#### 关于构造

箭头函数无法作为一个构造函数，所以无法通过`new`命令来构造

```js
const fn = () => {}
let _fn = new fn() // fn is not a constructor
```

如上，如果使用`new`来构造的化就会抛出`fn`不是一个**构造函数**

#### 关于参数对象

在箭头函数内是无法使用`arguments`即参数对象，因为在其函数体内部不存在`arguments`对象当然我们可以使用扩展运算符来代替其使用，比使用参数对象方便。

```js
const fn = () => {
    console.log(arguments)
}
fn() // arguments is not defined
```

#### 关于yield命令

箭头函数无法使用yield命令，也就是说无法将箭头函数转变为生成器函数，具体是为什么，我的直观感受就是作为生成器必须是`function*`，而箭头函数的形式无法作为一个生成器。

了解到这里，下面我们来看看一道经典的面试题。

## 面试题

```js
let name = "猪痞恶霸";
let person = {
    name:"fzf404",
    fn: () => {
        setTimeout(() => {
            console.log(this.name);
        })
    }
}
person.fn();
```

上面是一道考察**箭头函数**，**this指向**，**作用域**的面试题，它的打印结果为`undefined`，我们来一点一点分析

- 使用`let`在下声明了一个`name`
- 再声明一个对象，内含一个`name`属性和一个方法，该方法使用定时器并打印`this.name`
- 调用对象的这个方法，`this`开始寻找
- 定时器中的箭头函数没有`this`，向上寻找，到达`person`，由于`person`是一个对象，所以它的`{}`包裹的不是作用域
- 继续向上寻找，到达了顶层对象`window`
- 查看`window`内是否含有`name`属性，由于使用`let`声明，所以其属性不在`window`中，打印出`undefined`



## 函数的尾调用

尾调用是什么，它能解决什么问题，他的存在意味着什么，下面我将带读者整体学习了解函数的尾调用

### 尾调用概念

尾调用指的是在函数的最后一步通过`return`调用**另一个函数**

````js
function fn() {
    return _fn()
}
````

如上就是一个标准的函数尾调用

### 尾调用的作用

尾调用的作用非常重要，它可以为我们节省在函数调用时的内存，我们先来看一下函数执行的底层原来，再来了解尾调用是如何节省内存的

#### 函数执行中的帧

伴随函数的执行，函数会在内存中生成一个**调用帧**，我们先设定A,B,C三个函数，通过下面的形式调用（注意下面是普通的函数调用）

```js
fn_A() {
    fn_B()
}
fn_B() {
    fn_C()
}
```

如上：A函数执行，执行B函数，B函数内执行C函数，函数执行的过程是这样的：

- A执行生成一个A调用帧，在内部执行B函数
- B函数生成一个调用帧在A调用帧上方
- B函数内执行C函数，C函数执行生成一个调用帧在B调用帧上方，其本质就是一个**调用帧栈**
- C函数执行完毕，C调用帧出栈
- B函数执行完毕，B调用帧出栈
- A函数执行完毕，A调用帧出栈

通过以上过程就能了解函数执行中会生成调用帧占用内存，而不断地嵌套函数会占据越来越多的内存空间，下面我们来看看尾调用是如何改变这一过程达到优化的效果。

#### 尾调用优化的过程

那么如果我们使用尾调用来执行函数内部的函数。它的过程是怎么样的？

```js
fn_A() {
   return fn_B()
}
fn_B() {
   return fn_C()
}
```

- A执行生成一个A调用帧入栈
- 由于B函数在尾部执行，无需A的资源，所有A调用帧出栈，生成B调用帧入栈
- B函数执行，尾部调用C函数，无需B的资源，B调用帧出栈出栈，生成C调用帧入栈
- C执行结束，C调用帧出栈

尾调用：在执行A函数中的B函数的前就可以对A调用帧进行出栈处理，也就是说在这连续嵌套一过程中，栈中只有一个调用帧，大大节省了内存空间。

**注意**：真正的尾调用是需要考虑到资源的占用，即B函数执行不需要A函数内的资源，才能算是真正的尾调用

### 一种特殊的尾调用

当尾调用的函数是自身的时候就诞生了一种特殊的尾调用形式即**尾递归**

```js
function fn() {
    return fn()
}
```

正常的递归使用如果过多的话会产生栈溢出的现象，所以可以使用尾递归来解决这个问题，我们来看下面的例子
```js
function fn(n) {
    if(n === 1) return 1
    return n * fn(n-1)
}
console.log(fn(6)); // 720
```

如上是一个普通的递归函数求阶乘，那么我们可以使用尾递归来优化这个过程

```js
function fn(n, tol) {
  if (n === 1) return tol;
  return fn(n - 1, n * tol);
}
console.log(fn(6, 1)); // 720
```

### 尾递归的实现

需要注意的是我们只有在严格模式下，才能开启尾调用模式，所以在其他场景我们需要使用其他的解决方案来替代尾调用，尾递归也同理，因为尾递归的过程其实是循环调用，所以利用循环调用可以变相实现尾递归，这里涉及到了一个名词：**蹦床函数**

```js
function trampoline(f) {
  while (f && f instanceof Function) {
    f = f();
  }
  return f;
}
```

如上就是一个蹦床函数的封装，传入的参数是要进行递归的函数，其作用是代替递归，进行循环调用传入参数，下面我们来看看具体应用

```js
function num (x,y) {
    if(y > 0) {
        return num(x+1,y-1)
    }else {
        return x
    }
}
num(1,10000) // Maximum call stack size exceeded
```

`Maximum call stack size exceeded`就是栈溢出的报错，递归直接使用如果次数过多就会造成这样的现象，那么我们下面搭配蹦床函数使用

```js
function trampoline(f) {
  while (f && f instanceof Function) {
    f = f();
  }
  return f;
}

function num(x, y) {
  if (y > 0) {
    return num.bind(null, x + 1, y - 1);
  } else {
    return x;
  }
}
console.log(trampoline(num(1, 1000))); // 1001
```

通过蹦床函数将递归函数纳入，以循环的形式调用，最后得到结果，不会发生栈溢出现象，总结来看，尾调用是切断函数与尾调用函数之间的联系，用完即释放，藕断丝不连，不占用内存的效果。





